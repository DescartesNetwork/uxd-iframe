{"version":3,"file":"static/js/src_os_store_devTools_ts-src_os_store_mints_reducer_ts-src_os_view_wallet_lib_cloverWallet_ts-abf022.5ecccfef.chunk.js","mappings":"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","sources":["os/configs/sol.config.ts","os/configs/register.config.ts","os/configs/index.ts","os/store/devTools.ts","os/store/mints.reducer.ts","os/view/wallet/lib/baseWallet.ts","os/view/wallet/lib/cloverWallet.ts","os/view/wallet/lib/coin98Wallet.ts","os/view/wallet/lib/decorators.ts","os/view/wallet/lib/guestWallet.ts","os/view/wallet/lib/phantomWallet.ts","shared/session.ts","os/view/wallet/lib/secretkeyWallet.ts","os/view/wallet/lib/slopeWallet.ts","os/view/wallet/lib/solflareExtWallet.ts","os/view/wallet/lib/solflareWebWallet.ts","os/view/wallet/lib/solletWebWallet.ts","shared/dataloader/cache.ts","shared/dataloader/constant.ts","shared/dataloader/request.ts","shared/pdb/index.ts","shared/pdb/ipfs.ts"],"sourcesContent":["import { Net, rpc } from 'shared/runtime'\n\nconst SOLVARS = {\n  spltAddress: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  splataAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n}\n\n/**\n * Contructor\n */\ntype Conf = {\n  node: string\n  swapAddress: string\n  taxmanAddress: string\n  platformFee: number\n} & typeof SOLVARS\n\nconst conf: Record<Net, Conf> = {\n  /**\n   * Development configurations\n   */\n  devnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n    platformFee: 5000,\n  },\n\n  /**\n   * Staging configurations\n   */\n  testnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n    platformFee: 5000,\n  },\n\n  /**\n   * Production configurations\n   */\n  mainnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: 'SSW7ooZ1EbEognq5GosbygA3uWW1Hq1NsFq6TsftCFV',\n    taxmanAddress: '9doo2HZQEmh2NgfT3Yx12M89aoBheycYqH1eaR5gKb3e',\n    platformFee: 5000,\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { Env } from 'shared/runtime'\n\nif (\n  typeof process.env.REACT_APP_ID !== 'string' ||\n  typeof process.env.REACT_APP_NAME !== 'string' ||\n  typeof process.env.REACT_APP_URL !== 'string'\n)\n  throw new Error(\n    'Please add REACT_APP_ID, REACT_APP_NAME, REACT_APP_URL in .env.local!',\n  )\n\n/**\n * Contructor\n */\n\ntype Conf = {\n  devAppId: string\n  extra: SenReg\n  senreg: string\n}\n\nconst DEFAULT_APP_ID = process.env.REACT_APP_ID\nconst devApp = {\n  [DEFAULT_APP_ID]: {\n    url: process.env.REACT_APP_URL,\n    appId: DEFAULT_APP_ID,\n    name: process.env.REACT_APP_NAME,\n    author: {\n      name: process.env.REACT_APP_AUTHOR_NAME || '',\n      email: process.env.REACT_APP_AUTHOR_EMAIL || '',\n    },\n    tags: (process.env.REACT_APP_TAGS || '')\n      .split(',')\n      .map((tag) => tag.trim()),\n    description: process.env.REACT_APP_DESCRIPTION || '',\n    verified: false,\n  },\n}\n\nconst conf: Record<Env, Conf> = {\n  /**\n   * Development configurations\n   */\n  development: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Staging configurations\n   */\n  staging: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Production configurations\n   */\n  production: {\n    devAppId: DEFAULT_APP_ID,\n    extra: {},\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { net, env } from 'shared/runtime'\nimport sol from './sol.config'\nimport register from './register.config'\n\nconst configs = {\n  sol: sol[net],\n  register: register[env],\n}\n\n/**\n * Module exports\n */\nexport default configs\n","import { PublicKey } from '@solana/web3.js'\nimport BN from 'bn.js'\n\n// Bugfix performance\n// https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/Troubleshooting.md#excessive-use-of-memory-and-cpu\nexport const devTools = (appName: string): any => {\n  if (process.env.REACT_APP_ENV !== 'development') return false\n  return {\n    name: appName,\n    actionSanitizer: ({ payload, type }: { payload: any; type: string }) => ({\n      payload,\n      type,\n    }),\n  }\n}\n\n// BigInt Serialization Middleware\n// https://redux-toolkit.js.org/api/serializabilityMiddleware\nconst isPlain = (val: any): boolean => {\n  const isPlainObject = (obj: object): boolean => {\n    if (obj === null) return false\n    const proto = Object.getPrototypeOf(obj)\n    return proto !== null && Object.getPrototypeOf(proto) === null\n  }\n  return (\n    typeof val === 'undefined' ||\n    val === null ||\n    typeof val === 'string' ||\n    typeof val === 'boolean' ||\n    typeof val === 'number' ||\n    Array.isArray(val) ||\n    isPlainObject(val) ||\n    typeof val === 'bigint' ||\n    val instanceof PublicKey ||\n    val instanceof BN ||\n    Buffer.isBuffer(val)\n  )\n}\nBigInt.prototype.toJSON = function () {\n  return this.toString() // https://github.com/GoogleChromeLabs/jsbi/issues/30\n}\nexport const bigintSerializationMiddleware = {\n  serializableCheck: {\n    isSerializable: isPlain,\n  },\n}\n","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { account, MintData } from '@senswap/sen-js'\n\n/**\n * Interface & Utility\n */\n\nexport type MintsState = Record<string, MintData>\n\n/**\n * Store constructor\n */\n\nconst NAME = 'mints'\nconst initialState: MintsState = {}\n\n/**\n * Actions\n */\n\nexport const getMint = createAsyncThunk<\n  MintsState,\n  { address: string; force?: boolean },\n  { state: any }\n>(`${NAME}/getMint`, async ({ address, force = false }, { getState }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid mint address')\n  if (!force) {\n    const {\n      accounts: { [address]: data },\n    } = getState()\n    if (data) return { [address]: data }\n  }\n  const { splt } = window.sentre\n  const raw = await splt.getMintData(address)\n  return { [address]: raw }\n})\n\nexport const upsetMint = createAsyncThunk<\n  MintsState,\n  { address: string; data: MintData },\n  { state: any }\n>(`${NAME}/upsetMint`, async ({ address, data }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid address')\n  if (!data) throw new Error('Data is empty')\n  return { [address]: data }\n})\n\nexport const deleteMint = createAsyncThunk(\n  `${NAME}/deleteMint`,\n  async ({ address }: { address: string }) => {\n    if (!account.isAddress(address)) throw new Error('Invalid address')\n    return { address }\n  },\n)\n\n/**\n * Usual procedure\n */\n\nconst slice = createSlice({\n  name: NAME,\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =>\n    void builder\n      .addCase(\n        getMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        upsetMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        deleteMint.fulfilled,\n        (state, { payload }) => void delete state[payload.address],\n      ),\n})\n\nexport default slice.reducer\n","import { Transaction } from '@solana/web3.js'\nimport { Provider, WalletInterface, SignedMessage } from '@senswap/sen-js'\n\nimport storage from 'shared/storage'\n\nclass BaseWallet implements WalletInterface {\n  readonly walletType: string\n\n  constructor(walletType: string) {\n    this.walletType = walletType\n    storage.set('WalletType', this.walletType)\n  }\n\n  async getProvider(): Promise<Provider> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async getAddress(): Promise<string> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async signMessage(message: string): Promise<SignedMessage> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async verifySignature(\n    signature: string,\n    message: string,\n    address?: string,\n  ): Promise<boolean> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async disconnect(): Promise<void> {\n    storage.clear('WalletType')\n    const provider = await this.getProvider()\n    provider.disconnect()\n  }\n}\n\nexport default BaseWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass CloverWallet extends BaseWallet {\n  constructor() {\n    super('Clover')\n  }\n\n  async getProvider() {\n    const { clover_solana } = window\n    if (!clover_solana?.isCloverWallet)\n      throw new Error('Wallet is not connected')\n    return clover_solana\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const address = await provider.getAccount()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default CloverWallet\n","import { Transaction } from '@solana/web3.js'\nimport { account, SignedMessage } from '@senswap/sen-js'\nimport { decode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass Coin98Wallet extends BaseWallet {\n  constructor() {\n    super('Coin98')\n  }\n\n  async getProvider() {\n    const { sol } = window?.coin98 || {}\n    if (!sol) throw new Error('Wallet is not connected')\n    return sol\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const [address] = (await provider.request({ method: 'sol_accounts' })) || []\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const { signature: sig } = await provider.request({\n      method: 'sol_sign',\n      params: [transaction],\n    })\n    const signature = decode(sig)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    const { signatures } = await provider.request({\n      method: 'sol_signAllTransactions',\n      params: [transactions],\n    })\n    signatures.forEach((sig: string, i: number) => {\n      const signature = decode(sig)\n      transactions[i].addSignature(publicKey, signature)\n    })\n    return transactions\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const data = await provider.request({\n      method: 'sol_sign',\n      params: [message],\n    })\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const valid = await account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default Coin98Wallet\n","import { Transaction, SystemProgram, PublicKey } from '@solana/web3.js'\n\nimport configs from 'os/configs'\n\nconst {\n  sol: { taxmanAddress, platformFee },\n} = configs\n\nexport const addFeeInstruction = (\n  tx: Transaction,\n  payer: PublicKey,\n): Transaction => {\n  for (const { signature } of tx.signatures) {\n    if (signature) return tx\n  }\n  const ix = SystemProgram.transfer({\n    fromPubkey: payer,\n    toPubkey: new PublicKey(taxmanAddress),\n    lamports: platformFee,\n  })\n  tx.add(ix)\n  return tx\n}\n\nexport const collectFee = (\n  target: any,\n  memberName: string,\n  descriptor: PropertyDescriptor,\n) => {\n  const original = descriptor.value\n  descriptor.value = async function (tx: Transaction) {\n    const payer = tx.feePayer || (await target.getAddress())\n    const chagredTx = addFeeInstruction(tx, payer)\n    return original.call(target, chagredTx)\n  }\n}\n\nexport const collectFees = (\n  target: any,\n  memberName: string,\n  descriptor: PropertyDescriptor,\n) => {\n  const original = descriptor.value\n  descriptor.value = async (txs: Transaction[]) => {\n    let chargedTxs = []\n    for (const tx of txs) {\n      const payer = tx.feePayer || (await target.getAddress())\n      const chagredTx = addFeeInstruction(tx, payer)\n      chargedTxs.push(chagredTx)\n    }\n    return original.call(target, chargedTxs)\n  }\n}\n","import { Transaction } from '@solana/web3.js'\nimport { Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nexport const GUEST_ADDRESS = 'GuestAccount11111111111111111111111111111111'\n\ntype ExpanedProvider = Provider & { address: string }\n\nclass GuestWallet extends BaseWallet {\n  constructor(callback: () => void = () => {}) {\n    super('Guest')\n\n    this._callback = callback\n  }\n\n  private _callback = () => {}\n  private _error = () => {\n    throw new Error(\n      'You are in the Guest Mode. Please connect your personal wallet to proceed the action.',\n    )\n  }\n\n  async getProvider(): Promise<ExpanedProvider> {\n    const provider = {\n      address: GUEST_ADDRESS,\n      disconnect: () => {},\n    }\n    return provider\n  }\n\n  async getAddress(): Promise<string> {\n    const { address } = await this.getProvider()\n    return address\n  }\n\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    await this._callback()\n    return this._error()\n  }\n\n  async signAllTransaction(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    await this._callback()\n    return this._error()\n  }\n\n  async signMessage(message: string) {\n    await this._callback()\n    return this._error()\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    await this._callback()\n    return this._error()\n  }\n}\n\nexport default GuestWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass PhantomWallet extends BaseWallet {\n  constructor() {\n    super('Phantom')\n  }\n\n  async getProvider() {\n    const { solana } = window\n    if (!solana?.isPhantom) throw new Error('Wallet is not connected')\n    if (solana.isConnected) return solana\n    return await new Promise((resolve) => {\n      solana.on('connect', () => resolve(solana))\n      return solana.connect()\n    })\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default PhantomWallet\n","const KEY = 'sentre'\nconst driver = window.sessionStorage\n\nconst convert = (value: string | null) => {\n  try {\n    if (!value) return null\n    return JSON.parse(value)\n  } catch (e) {\n    return false\n  }\n}\n\nconst session = {\n  set: (key: string, value: any) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') data = {}\n    data[key] = value\n    driver.setItem(KEY, JSON.stringify(data))\n  },\n\n  get: (key: string) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') return null\n    return data[key]\n  },\n\n  clear: (key: string) => {\n    session.set(key, null)\n  },\n}\n\nexport default session\n","import { Transaction, Keypair } from '@solana/web3.js'\nimport { sign, hash } from 'tweetnacl'\nimport { account, Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport session from 'shared/session'\nimport storage from 'shared/storage'\nimport { collectFee, collectFees } from './decorators'\n\ntype ExpanedProvider = Provider & { keypair: Keypair }\n\nclass SecretKeyWallet extends BaseWallet {\n  constructor(secretKey: string, password?: string) {\n    super('SecretKey')\n\n    SecretKeyWallet.setSecretKey(secretKey, password)\n  }\n\n  static xor(\n    a: Buffer | Uint8Array,\n    b: Buffer | Uint8Array,\n  ): Buffer | Uint8Array {\n    if (a.length !== b.length)\n      throw new Error('Cannot XOR two different-length buffers')\n    const r = Buffer.alloc(a.length)\n    for (let i = 0; i < r.length; i++) r[i] = a[i] ^ b[i]\n    return r\n  }\n\n  static getPassword(): string {\n    let pwd = session.get('Password')\n    if (!pwd) pwd = window.prompt('Input the password:')\n    if (!pwd) throw new Error('User rejects to sign the transaction')\n    session.set('Password', pwd)\n    return pwd\n  }\n\n  static setSecretKey(secretKeyString: string, pwd?: string): void {\n    const { secretKey } = account.fromSecretKey(secretKeyString) || {}\n    if (!secretKey) throw new Error('Invalid secret key')\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = SecretKeyWallet.xor(seed, secretKey)\n    storage.set('SecretKey', confusedSecretKey.toString('hex'))\n  }\n\n  static getSecretKey(pwd?: string): string {\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = storage.get('SecretKey')\n    if (!confusedSecretKey) throw new Error('Invalid secret key')\n    const secretKey = SecretKeyWallet.xor(\n      seed,\n      Buffer.from(confusedSecretKey, 'hex'),\n    )\n    return secretKey.toString('hex')\n  }\n\n  async getProvider(): Promise<ExpanedProvider> {\n    const secretKey = SecretKeyWallet.getSecretKey()\n    const keypair = account.fromSecretKey(secretKey)\n    if (!keypair) throw new Error('Cannot get the keystore-based provider')\n    const provider = {\n      keypair,\n      disconnect: () => session.clear('SecretKey'),\n    }\n    return provider\n  }\n\n  async getAddress(): Promise<string> {\n    const { keypair } = await this.getProvider()\n    return keypair.publicKey.toBase58()\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const confirmed = window.confirm('Please confirm to sign the transaction!')\n    if (!confirmed) throw new Error('User rejects to sign the transaction')\n    const { keypair } = await this.getProvider()\n    const signData = transaction.serializeMessage()\n    const publicKey = keypair.publicKey\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const signature = sign.detached(signData, keypair.secretKey)\n    transaction.addSignature(publicKey, Buffer.from(signature))\n    return transaction\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const confirmed = window.confirm('Please confirm to sign the transactions!')\n    if (!confirmed) throw new Error('User rejects to sign the transactions')\n    const { keypair } = await this.getProvider()\n    const txs: Transaction[] = []\n    for (const transaction of transactions) {\n      const signData = transaction.serializeMessage()\n      const publicKey = keypair.publicKey\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n      const signature = sign.detached(signData, keypair.secretKey)\n      transaction.addSignature(publicKey, Buffer.from(signature))\n      txs.push(transaction)\n    }\n    return txs\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const confirmed = window.confirm(\n      `Please confirm to sign the message! Message: ${message}`,\n    )\n    if (!confirmed) throw new Error('User rejects to sign the message')\n    const { keypair } = await this.getProvider()\n    const secretKey = Buffer.from(keypair.secretKey).toString('hex')\n    const data = account.signMessage(message, secretKey)\n    return { ...data }\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const valid = account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default SecretKeyWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account } from '@senswap/sen-js'\nimport { decode, encode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass SlopeWallet extends BaseWallet {\n  private provider: any\n  constructor() {\n    super('Slope')\n    this.provider = null\n  }\n\n  async getProvider() {\n    const { Slope } = window || {}\n    if (!Slope) throw new Error('Cannot connect to Slope')\n    if (this.provider) return this.provider\n    this.provider = new Slope()\n    await this.provider.connect()\n    return this.provider\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const { data } = await provider.connect()\n    if (!data.publicKey) throw new Error('Wallet is not connected')\n    return data.publicKey\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const message = encode(transaction.serializeMessage())\n    const { msg, data } = await provider.signTransaction(message)\n    if (!data.publicKey || !data.signature) throw new Error(msg)\n    const signature = decode(data.signature)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    const messages = transactions.map((transaction) =>\n      encode(transaction.serializeMessage()),\n    )\n    const { msg, data } = await provider.signAllTransactions(messages)\n    if (!data.publicKey || data.signatures?.length !== transactions.length)\n      throw new Error(msg)\n    data.signatures.forEach((sig: string, i: number) => {\n      const signature = decode(sig)\n      transactions[i].addSignature(publicKey, signature)\n    })\n    return transactions\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    const slopeAddress = address || (await this.getAddress())\n    const publicKey = account.fromAddress(slopeAddress)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SlopeWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass SolflareExtWallet extends BaseWallet {\n  constructor() {\n    super('SolflareExtension')\n  }\n\n  async getProvider() {\n    const { solflare } = window\n    if (!solflare.isSolflare) throw new Error('Wallet is not connected')\n    if (solflare.isConnected) return solflare\n    return await new Promise((resolve) => {\n      solflare.on('connect', () => resolve(solflare))\n      return solflare.connect()\n    })\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareExtWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\nimport { collectFee, collectFees } from './decorators'\n\nconst {\n  sol: { node },\n} = configs\nconst PROVIDER_URL = 'https://solflare.com/provider'\nconst PROVIDER: WalletAdapter & Provider = new WalletAdapter(PROVIDER_URL, node)\n\nclass SolflareWebWallet extends BaseWallet {\n  constructor() {\n    super('SolflareWeb')\n  }\n\n  async getProvider() {\n    if (!PROVIDER.connected) await PROVIDER.connect()\n    return PROVIDER\n  }\n\n  async getAddress() {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Solflare')\n    return provider.publicKey.toBase58()\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareWebWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\nimport { collectFee, collectFees } from './decorators'\n\nconst {\n  sol: { node },\n} = configs\nconst PROVIDER_URL = 'https://www.sollet.io'\nconst PROVIDER: WalletAdapter & Provider = new WalletAdapter(PROVIDER_URL, node)\n\nclass SolletWallet extends BaseWallet {\n  constructor() {\n    super('SolletWeb')\n  }\n\n  async getProvider() {\n    if (!PROVIDER.connected) await PROVIDER.connect()\n    return PROVIDER\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Sollet Web')\n    return provider.publicKey.toBase58()\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolletWallet\n","import { DEFAULT_CACHE_CONFIG } from './constant'\nimport { CacheConfig } from './constant'\n\nexport class SingleFlightCache {\n  private static mapCache = new Map<string, any>()\n\n  static set(\n    key: string,\n    value: any,\n    configs: CacheConfig = DEFAULT_CACHE_CONFIG,\n  ) {\n    this.mapCache.set(key, value)\n    setTimeout(() => {\n      this.mapCache.delete(key)\n    }, configs.ttl)\n  }\n\n  static get(key: string) {\n    return this.mapCache.get(key)\n  }\n}\n","export type LimitConfig = {\n  calls: number\n  time: number\n}\n\nexport type CacheConfig = {\n  ttl: number // millisecond\n}\n\nexport type SingleFlightConfig = {\n  limit?: LimitConfig\n  cache?: CacheConfig\n}\n\n// 10 request per 1 second\nexport const DEFAULT_LIMIT_CONFIG: LimitConfig = {\n  calls: 10,\n  time: 1000,\n}\n\n// 10 request per 1 second\nexport const DEFAULT_CACHE_CONFIG: CacheConfig = {\n  ttl: 30000,\n}\n\nexport const DEFAULT_SINGLE_FLIGHT_CONFIG: SingleFlightConfig = {\n  limit : DEFAULT_LIMIT_CONFIG,\n  cache: DEFAULT_CACHE_CONFIG\n}","export interface IRequestQueue {\n  key: string\n  add(resolve: any, reject: any): void\n  resolves(data: any): void\n  rejects(error: any): void\n}\n\nexport class RequestQueue implements IRequestQueue {\n  key = ''\n  private resolveQueue: any[] = []\n  private rejectQueue: any[] = []\n  constructor(key: string) {\n    this.key = key\n  }\n\n  add(resolve: any, reject: any) {\n    this.resolveQueue.push(resolve)\n    this.rejectQueue.push(reject)\n  }\n\n  resolves(data: any) {\n    while (this.resolveQueue.length > 0) {\n      const resolve = this.resolveQueue.shift()\n      resolve(data)\n    }\n  }\n\n  rejects(error: any) {\n    while (this.rejectQueue.length > 0) {\n      const reject = this.rejectQueue.shift()\n      reject(error)\n    }\n  }\n}\n","import localForage from 'localforage'\nimport { account } from '@senswap/sen-js'\nimport IPFS from './ipfs'\n\n/**\n * Persistent Database\n */\nclass PDB {\n  readonly dbName: string\n  private driver: any\n  private ipfs: IPFS\n\n  constructor(walletAddress: string) {\n    if (!account.isAddress(walletAddress)) throw new Error('Invalid address')\n    this.dbName = walletAddress\n    this.driver = [localForage.WEBSQL, localForage.LOCALSTORAGE]\n    this.ipfs = new IPFS()\n  }\n\n  /**\n   * Local\n   */\n\n  createInstance = (appId: string): LocalForage => {\n    return localForage.createInstance({\n      driver: this.driver,\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  dropInstance = async (appId: string): Promise<void> => {\n    const instance = this.createInstance(appId)\n    await instance.clear()\n    return await localForage.dropInstance({\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  all = async (): Promise<any> => {\n    let data: any = {}\n    const appIds = (\n      ((await this.createInstance('sentre').getItem('appIds')) as string[]) ||\n      []\n    )\n      .flat()\n      .concat(['sentre'])\n    for (const appId of appIds) {\n      data[appId] = {}\n      const instance = this.createInstance(appId)\n      await instance.iterate((value: string, key: string) => {\n        data[appId][key] = value\n      })\n    }\n    return data\n  }\n\n  /**\n   * Cloud\n   */\n\n  fetch = async (cid: string) => {\n    return await this.ipfs.get(cid)\n  }\n\n  backup = async () => {\n    const data = await this.all()\n    return await this.ipfs.set(data)\n  }\n\n  restore = async (cid: string) => {\n    // Download data\n    const data = await this.fetch(cid)\n    // Apply to storage\n    for (const appId in data) {\n      const instance = await this.createInstance(appId)\n      for (const key in data[appId]) {\n        const value = data[appId][key]\n        await instance.setItem(key, value)\n      }\n    }\n    return data\n  }\n}\n\nexport default PDB\n\n/**\n * High abtraction pdb for app\n */\nexport const createPDB = (walletArress: string, appId: string) => {\n  return account.isAddress(walletArress)\n    ? new PDB(walletArress).createInstance(appId)\n    : undefined\n}\n","import { create, isIPFS } from 'ipfs-core'\nimport { asyncWait } from 'shared/util'\n\nclass IPFS {\n  private _ipfs: any = async () => {\n    try {\n      if (!window.ipfs) window.ipfs = await create()\n      return window.ipfs\n    } catch (er) {\n      await asyncWait(500)\n      return await this._ipfs()\n    }\n  }\n\n  static isCID = (cid: string | undefined | null): boolean => {\n    try {\n      if (!cid) return false\n      return isIPFS.multihash(cid)\n    } catch (er) {\n      return false\n    }\n  }\n\n  get = async (cid: string) => {\n    if (!IPFS.isCID(cid)) throw new Error('Invalid CID')\n    const ipfs = await this._ipfs()\n    const stream = await ipfs.cat(cid)\n    let raw = ''\n    for await (const chunk of stream) raw += Buffer.from(chunk).toString()\n    const data = JSON.parse(raw)\n    return data\n  }\n\n  set = async (data: object): Promise<string> => {\n    if (!data) throw new Error('Empty data')\n    const raw = JSON.stringify(data)\n    const ipfs = await this._ipfs()\n    const { cid } = await ipfs.add(raw)\n    return cid.toString()\n  }\n}\n\nexport default IPFS\n"],"names":["SOLVARS","spltAddress","splataAddress","devnet","node","rpc","swapAddress","taxmanAddress","platformFee","testnet","mainnet","DEFAULT_APP_ID","process","devApp","url","appId","name","author","email","tags","split","map","tag","trim","description","verified","development","devAppId","extra","senreg","staging","production","sol","net","register","env","devTools","appName","BigInt","prototype","toJSON","this","toString","bigintSerializationMiddleware","serializableCheck","isSerializable","val","Array","isArray","obj","proto","Object","getPrototypeOf","isPlainObject","PublicKey","BN","Buffer","isBuffer","NAME","getMint","createAsyncThunk","async","address","force","getState","account","Error","accounts","data","splt","window","sentre","getMintData","upsetMint","deleteMint","createSlice","initialState","reducers","extraReducers","builder","addCase","fulfilled","state","payload","assign","constructor","walletType","storage","transaction","transactions","message","signature","getProvider","disconnect","CloverWallet","BaseWallet","super","clover_solana","isCloverWallet","provider","getAccount","getAddress","publicKey","feePayer","signTransaction","forEach","signAllTransactions","encodedMsg","TextEncoder","encode","sig","signMessage","from","bufSig","nacl","toBuffer","collectFee","collectFees","Coin98Wallet","coin98","request","method","params","decode","addSignature","signatures","i","configs","addFeeInstruction","tx","payer","ix","SystemProgram","fromPubkey","toPubkey","lamports","add","target","memberName","descriptor","original","value","chagredTx","call","chargedTxs","txs","push","GuestWallet","callback","_callback","_error","PhantomWallet","solana","isPhantom","isConnected","Promise","resolve","on","connect","KEY","driver","sessionStorage","convert","JSON","parse","e","session","set","key","getItem","setItem","stringify","get","clear","SecretKeyWallet","secretKey","password","setSecretKey","a","b","length","r","alloc","pwd","prompt","secretKeyString","getPassword","seed","hash","confusedSecretKey","xor","getSecretKey","keypair","toBase58","confirm","signData","serializeMessage","sign","SlopeWallet","Slope","msg","messages","slopeAddress","SolflareExtWallet","solflare","isSolflare","PROVIDER","WalletAdapter","SolflareWebWallet","connected","SolletWallet","SingleFlightCache","DEFAULT_CACHE_CONFIG","mapCache","setTimeout","delete","ttl","Map","DEFAULT_SINGLE_FLIGHT_CONFIG","limit","calls","time","cache","RequestQueue","resolveQueue","rejectQueue","reject","resolves","shift","rejects","error","PDB","walletAddress","dbName","ipfs","createInstance","localForage","storeName","dropInstance","instance","all","appIds","flat","concat","iterate","fetch","cid","backup","restore","IPFS","_ipfs","create","er","asyncWait","isCID","stream","cat","raw","chunk","isIPFS"],"sourceRoot":""}